<link rel="import" href="../polymer/polymer-element.html">

<!--
`<a-timer>` is a countdown timer unusually capable to be driven by properties only.

```html
<a-timer start-at="30"></a-timer>
```

'Events' are signaled setting correspondent 'signal' property to true. 
And then to false again after the second passes. 

```html
<a-timer start-at="30" signal-finish="{{finished}}"></a-timer>
```

You can observe changes to `[[finish]]`, acting when it is set to true, 
as you would with an traditionally fired event.

`<a-timer>` may easily be attached to graphic elements.

```html
<a-timer start-at="30" current-time="{{currentTime}}"></a-timer>
[[currentTime]]
```

Start/stop `<a-timer>` by changing `run` property to true/false.
As you would with a traditional method, but using a property instead.

```html
<a-timer start-at="30" run="[[run]]"></a-timer>
```

Reset `<a-timer>` by changing `reset` property to true.
As you would with a traditional method, but using a property instead.
It will be reset at the instant the property changes to true.

```html
<a-timer start-at="30" reset="[[reset]]"></a-timer>
```

It may include one more optional alert `alert-also-at`, 
correspondingly signaled by `signal-alert-also-at`.

```html
<a-timer 
  start-at="30" 
  alert-also-at="10" 
  signal-alert-also-at="{{signalAlertAlsoAt}}" 
  signal-finish="{{finished}}>
</a-timer>
```

It may alert periodically.

```html
<a-timer start-at="30" alert-tick="2" signal-alert-tick="{{signalAlertTick}}"></a-timer>
```
A tick is meant to be higher than 1 second. For 1 second ticks, 
you can watch changes directly on `current-time` property, which updates every second. 

@element a-timer
@hero hero.svg
@demo demo/index.html
-->

<dom-module id="a-timer">
  <template>
    <style>
       :host {
        display: block;
      }
    </style>
    <div on-click="start">start</div>
    <div on-click="stop">stop</div>
    <div on-click="reset">reset</div>
    <div class="time">[[currentTime]]</div>
    <div>signalAlertAlsoAt: [[signalAlertAlsoAt]]</div>
    <div>signalFinish: [[signalFinish]]</div>
    <div>resetProp: [[resetProp]]</div>

  </template>

  <script>
    /**
     * `a-timer`
     * A countdown timer element
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class ATimer extends Polymer.Element {
      static get is() { return 'a-timer'; }
      static get properties() {
        return {
          /**
          * Start time in seconds.
          */
          startTime: {
            type: Number,
            value: 30,
          },

          /**
          * The current time in seconds.
          */
          currentTime: {
            type: Number,
            computed: 'computeCurrentTime(_preciseCurrentTime)',
          },

          /**
          * An aditional time, in seconds, to alert.
          */
          alertAlsoAt: {
            type: Number,
            value: null,
          },

          /**
          * A period, in seconds, to alert periodically.
          */
          alertTick: {
            type: Number,
            value: null,
          },

          /**
          * A property, instead of a traditional method, to start/stop the timer.
          */
          run: {
            type: Boolean,
            value: false,
          },

          /**
          * A property, instead of a traditional method, to reset the timer.
          */
          resetProp: {
            type: Boolean,
            value: true,
          },

          /**
          * A property, instead of a traditional event, to signal a periodic 'tick' alert set by ```alertTick```.
          */
          signalAlertTick: {
            type: Boolean,
            value: false,
          },

          /**
          * A property, instead of a traditional event, to signal an additional alert set by ```alertAt```.
          */
          signalAlertAlsoAt: {
            type: Boolean,
            value: false,
          },

          /**
          * A property, instead of a traditional event, to signal finish.
          */
          signalFinish: {
            type: Boolean,
            value: false,
          },

          _preciseCurrentTime: {
            type: Number,
            value: null,
          },
          _intervalId: {
            type: String,
            value: null,
          },
          _startTimestamp: {
            type: Number,
            value: null,
          },
          _startTimestampDiffToMiddle: {
            type: Number,
            value: null,
          },
        };
      }

      static get observers() {
        return [
          '_runChanged(run)',
          '_resetChanged(resetProp)',
          '_signalFinishChanged(signalFinish)',
          '_signalAlertAlsoAtChanged(signalAlertAlsoAt)',
        ];
      }

      computeCurrentTime(_preciseCurrentTime) {
        return Math.floor(_preciseCurrentTime);
      }
      _runChanged(run) {
        console.log('run: ', run);
        run ? this._start() : this._stop();
      }
      _resetChanged(resetProp) {
        if (!resetProp) return;
        this._reset();
        this.set('resetProp', false);
      }
      _signalFinishChanged(signalFinish) {
        if (signalFinish) {
          console.log('signalFinish')
          this.dispatchEvent(new CustomEvent('finish'));
        }
      }
      _signalAlertAlsoAtChanged(signalAlertAlsoAt) {
        if (signalAlertAlsoAt) {
          this.dispatchEvent(new CustomEvent('alert', { detail: this.currentTime }));
        }
      }

      /**
      * Starts the timer.
      */
      start() {
        this.set('run', true);
      }

      /**
      * Stops the timer.
      */
      stop() {
        this.set('run', false);
      }

      /**
      * Resets the timer.
      */
      reset() {
        this.set('run', false);
        this.set('resetProp', true);
      }

      _start() {
        this.set('run', true);
        if (!this._preciseCurrentTime) {
          this.set('_preciseCurrentTime', this.startTime);
        }
        this._resetAlerts();
        clearInterval(this._intervalId);
        this._intervalId = setInterval(this._step.bind(this), 1000);
      }

      _stop() {
        this.set('run', false);
        this._startTimestamp = null;
        clearInterval(this._intervalId);
        // this._startTimestamp = null;
      }

      _reset() {
        this._resetAlerts();
        this.set('_preciseCurrentTime', this.startTime);
      }

      _resetAlerts() {
        this.set('signalAlertTick', false);
        this.set('signalAlertAlsoAt', false);
        this.set('signalFinish', false);
      }

      _step() {
        const agora = (new Date()).getTime();
        if (!this._startTimestamp) {
          this._startTimestampDiffToMiddle = (500 - (agora % 1000))
          this._startTimestamp = (agora + this._startTimestampDiffToMiddle - 500);
        }
        const agoraTryToBeAround500 = (agora + this._startTimestampDiffToMiddle);
        const diffInSeconds = (agoraTryToBeAround500 - this._startTimestamp) / 1000;
        const preciseCurrentTime = this.startTime - diffInSeconds;

        console.log(this.startTime, this.currentTime, preciseCurrentTime, diffInSeconds, '.')
        this.set('_preciseCurrentTime', (preciseCurrentTime))
        console.log(this.startTime, this.currentTime, preciseCurrentTime, diffInSeconds)
        // this.currentTime--;

        if (!this.signalAlertAlsoAt && this.currentTime <= this.alertAlsoAt) {
          this.set('signalAlertAlsoAt', true);
        }
        if (this.currentTime <= 0) {
          // this.set('currentTime', 0);
          // this._stop();
          // console.log(this.run);
          // console.log(this.run);
          this.set('signalFinish', true);
          this.set('run', false);
        }
        
      }

    }

    window.customElements.define(ATimer.is, ATimer);
  </script>
</dom-module>